>module Parser(parse) where

>import Formula
>import GenParse

>parse :: String -> Formula
>parse = topLevel formula

Parser for (extended) LTL formulas, generated by the following grammar:

formula0 ::= formula1 ("=>" formula1)* | formula1 ("||" formula1)*
formula1 ::= formula2 ("&&" formula2)*
formula2 ::= formula3 ("R" formula3)*
formula3 ::= "[]" formula3 | "O" formula3 | <+> formula3 i | formula4
formula4 ::= "Deadlocked" | "Live" | a | "!" a | "Available" a | 
             "True" | "False" | "(" formula0 ")"

Note that this implies that 

  [] phi && psi     ->  ([] phi) && psi
  phi && psi R chi  ->  phi && (psi R chi)
  O phi R psi       ->  (O phi) R psi
  phi R psi R chi   ->  phi R (psi R chi)

>formula = formula0

>formula0 =
>  formula1 ^^^ many (word1ws "=>" ^^> formula1) >>>
>    (\ (phi, psis) -> foldl Implies phi psis)

>formula1 =
>  formula2 ^^^ many (word1ws "||" ^^> formula2) >>>
>    (\ (phi, psis) -> foldl Or phi psis)

formula0 =
  ((check notReserved . wordws) <^^ word1ws "=>") ^^^ formula0 >>>
    (\ (a, phi) -> (Does a `And` phi) `Or` Doesnot a)
  |||
  formula1 ^^^ many (word1ws "||" ^^> formula1) >>>
    (\ (phi, psis) -> foldl Or phi psis)

>formula2 =
>  formula3 ^^^ many (word1ws "&&" ^^> formula3) >>> 
>    (\ (phi, psis) -> foldl And phi psis)

>formula3 = 
>  formula4 ^^^ many (word1ws "R " ^^> formula4) >>>  
>    (\ (phi, psis) -> foldl Release phi psis)

>formula4 = 
>  formula5 ^^^ many (word1ws "BU" ^^> word1ws "(" ^^> formula5 ^^^ word1ws "," ^^> number <^^ word1ws ")" ) >>>  
>    (\ (phi, psis) -> foldl BoundUntil phi psis)
    
>formula5 =
>  word1ws "[]" ^^> formula5 >>> Release Falsef
>  |||
>  word1ws "O " ^^> formula5 >>> Next
>  |||
>  word1ws "<+>" ^^> word1ws "(" ^^> formula5 ^^^ word1ws "," ^^> number <^^ word1ws ")" >>>
>     (\ (a, phi) -> (BoundEventually a phi))
>  |||
>  formula6

  (number <^^ word1ws "<+>") ^^^ formula3 >>>
     (\ (a, phi) -> (BoundEventually phi a))


  word1ws "<+>" ^^> word1ws "(" ^^> formula3 ^^^ word1ws "," ^^^ number ^^^ ")" >>> BoundEventually 

>formula6 = 
>  (check notReserved . wordws) >>> Does 
>  |||
>  word1ws "True" ^^> succeed Truef
>  |||
>  word1ws "False" ^^> succeed Falsef
>  |||
>  word1ws "Deadlocked" ^^> succeed Deadlocked
>  |||
>  word1ws "Live" ^^> succeed Live
>  |||
>  word1ws "Available " ^^> wordws >>> Available
>  |||
>  word1ws "!" ^^> wordws >>> Doesnot
>  |||
>  word1ws "(" ^^> formula <^^ word1ws ")"

>notReserved = (`notElem` ["True", "False", "Deadlocked", "Live", "Available"])

-- handleWord :: String -> Maybe(Formula,String)
handleWord "True" = succeed Truef
handleWord "False" = succeed Falsef
handleWord "Deadlocked" = succeed Deadlocked
handleWord "Live" = succeed Live
-- handleWord "Available" = wordws >>> Available
handleword a = Does a